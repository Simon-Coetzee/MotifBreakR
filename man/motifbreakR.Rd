% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/scoreMotif.R
\name{motifbreakR}
\alias{motifbreakR}
\title{Predict The Disruptiveness Of Single Nucleotide Polymorphisms On
Transcription Factor Binding Sites.}
\usage{
motifbreakR(snpList, pwmList, threshold, method = "default", bkg = c(A =
  0.25, C = 0.25, G = 0.25, T = 0.25), show.neutral = FALSE,
  verbose = FALSE, emp.p.value = TRUE, bootstrap.location = NULL,
  BPPARAM = bpparam())
}
\arguments{
\item{snpList}{The output of \code{snps.from.rsid} or \code{snps.from.bed}}

\item{pwmList}{An object of class \code{MotifList} containing the motifs that
you wish to interrogate}

\item{threshold}{Numeric; the minimum disruptiveness score for which to
report results}

\item{method}{Character; one of \code{default}, \code{log}, or \code{ic}; see
details.}

\item{bkg}{Numeric Vector; the background probabilites of the nucleotides
used with method=\code{log} method=\code{ic}}

\item{show.neutral}{Logical; include neutral changes in the output}

\item{verbose}{Logical; if running serially, show verbose messages}

\item{BPPARAM}{a BiocParallel object see \code{\link[BiocParallel]{register}}
and see \code{getClass("BiocParallelParam")} for additional parameter
classes.  Try \code{BiocParallel::registered()} to see what's availible and
for example \code{BiocParallel::bpparam("SerialParam")} would allow serial
evaluation.}
}
\value{
a GRanges object containing:
 \item{REF}{the reference allele for the SNP}
 \item{ALT}{the alternate allele for the SNP}
 \item{snpPos}{the coordinates of the SNP}
 \item{motifPos}{the coordinates of the SNP within the TF binding motif}
 \item{geneSymbol}{the geneSymbol corresponding to the TF of the TF binding motif}
 \item{dataSource}{the source of the TF binding motif}
 \item{providerName, providerId}{the name and id provided by the source}
 \item{seqMatch}{the sequence on the 5' -> 3' direction of the "+" strand
 that corresponds to DNA at the position that the TF binding motif was found.}
 \item{Refscore}{The score as determined by the scoring method, when the sequence contains the reference SNP allele}
 \item{Altscore}{The score as determined by the scoring method, when the sequence contains the alternate SNP allele}
 \item{alleleRef}{The proportional frequency of the reference allele at position \code{motifPos} in the motif}
 \item{alleleAlt}{The proportional frequency of the alternate allele at position \code{motifPos} in the motif}
 \item{effect}{one of weak, strong, or neutral indicating the strength of the effect.}
 each SNP in this object may be plotted with \code{\link{plotMB}}
}
\description{
Predict The Disruptiveness Of Single Nucleotide Polymorphisms On
Transcription Factor Binding Sites.
}
\details{
\pkg{motifbreakR} works with position probability matrices (PPM). PPM
are derived as the fractional occurrence of nucleotides A,C,G, and T at
each position of a position frequency matrix (PFM). PFM are simply the
tally of each nucleotide at each position across a set of aligned
sequences. With a PPM, one can generate probabilities based on the
genome, or more practically, create any number of position specific
scoring matrices (PSSM) based on the principle that the PPM contains
information about the likelihood of observing a particular nucleotide at
a particular position of a true transcription factor binding site. What
follows is a discussion of the three different algorithms that may be
employed in calls to the \pkg{motifbreakR} function via the \code{method}
argument.

Suppose we have a frequency matrix \eqn{M} of width \eqn{n} (\emph{i.e.} a
PPM as described above). Furthermore, we have a sequence \eqn{s} also of
length \eqn{n}, such that
\eqn{s_{i} \in \{ A,T,C,G \}, i = 1,\ldots n}. Each column of
\eqn{M} contains the frequencies of each letter in each position.

Commonly in the literature sequences are scored as the sum of log
probabilities:

\strong{Equation 1}

\deqn{F( s,M ) = \sum_{i = 1}^{n}{\log( \frac{M_{s_{i},i}}{b_{s_{i}}} )}}

where \eqn{b_{s_{i}}} is the background frequency of letter \eqn{s_{i}} in
the genome of interest. This method can be specified by the user as
\code{method='log'}.

As an alternative to this method, we introduced a scoring method to
directly weight the score by the importance of the position within the
match sequence. This method of weighting is accessed by specifying
\code{method='ic'} (information content). A general representation
of this scoring method is given by:

\strong{Equation 2}

\deqn{F( s,M ) = p( s ) \cdot \omega_{M}}

where \eqn{p_{s}} is the scoring vector derived from sequence \eqn{s} and matrix
\eqn{M}, and \eqn{w_{M}} is a weight vector derived from \eqn{M}. First, we
compute the scoring vector of position scores \eqn{p}:

\strong{Equation 3}

\deqn{p( s ) = ( M_{s_{i},i} ) \textrm{\ \ \ where\ \ \ } \frac{i = 1,\ldots n}{s_{i} \in \{ A,C,G,T \}}}

and second, for each \eqn{M} a constant vector of weights
\eqn{\omega_{M} = ( \omega_{1},\omega_{2},\ldots,\omega_{n} )}.

There are two methods for producing \eqn{\omega_{M}}. The first, which we
call weighted sum, is the difference in the probabilities for the two
letters of the polymorphism (or variant), \emph{i.e.}
\eqn{\Delta p_{s_{i}}}, or the difference of the maximum and minimum
values for each column of \eqn{M}:

\strong{Equation 4.1}

\deqn{\omega_{i} = \max \{ M_{i} \} - \min \{ M_{i} \}\textrm{\ \ \ \ where\ \ \ \ \ \ }i = 1,\ldots n}

The second variation of this theme is to weight by relative entropy.
Thus the relative entropy weight for each column \eqn{i} of the matrix is
given by:

\strong{Equation 4.2}

\deqn{\omega_{i} = \sum_{j \in \{ A,C,G,T \}}^{}{M_{j,i}\log_2( \frac{M_{j,i}}{b_{i}} )}\textrm{\ \ \ \ \ where\ \ \ \ \ }i = 1,\ldots n}

where \eqn{b_{i}} is again the background frequency of the letter \eqn{i}.

Thus, there are 3 possible algorithms to apply via the \code{method}
argument. The first is the standard summation of log probabilities
(\code{method='log'}). The second and third are the weighted sum and
information content methods (\code{method=default} and \code{method='ic'}) specified by
equations 4.1 and 4.2, respectively. \pkg{motifbreakR} assumes a
uniform background nucleotide distribution (\eqn{b}) in equations 1 and
4.2 unless otherwise specified by the user. Since we are primarily
interested in the difference between alleles, background frequency is
not a major factor, although it can change the results. Additionally,
inclusion of background frequency introduces potential bias when
collections of motifs are employed, since motifs are themselves
unbalanced with respect to nucleotide composition. With these cautions
in mind, users may override the uniform distribution if so desired. For
all three methods, \pkg{motifbreakR} scores and reports the reference
and alternate alleles of the sequence
(\eqn{F( s_{\textsc{ref}},M )} and
\eqn{F( s_{\textsc{alt}},M )}), and provides the matrix scores
\eqn{p_{s_{\textsc{ref}}}} and \eqn{p_{s_{\textsc{alt}}}} of the SNP (or
variant). The scores are scaled as a fraction of scoring range 0-1 of
the motif matrix, \eqn{M}. If either of
\eqn{F( s_{\textsc{ref}},M )} and
\eqn{F( s_{\textsc{alt}},M )} is greater than a user-specified
threshold (default value of 0.85) the SNP is reported. By default
\pkg{motifbreakR} displays only strong effects
(\eqn{\Delta p_{i} > 0.7}) but this behaviour can be
overridden.
}
\examples{
library(BSgenome.Hsapiens.UCSC.hg19)
 library(SNPlocs.Hsapiens.dbSNP.20120608)
 # prepare variants
 load(system.file("extdata", "pca.enhancer.snps.rda", package = "motifbreakR")) # loads snps.mb
 pca.enhancer.snps <- sample(snps.mb, 20)
 # Get motifs to interrogate
 data(hocomoco)
 motifs <- sample(hocomoco, 50)
 # run motifbreakR
 results <- motifbreakR(pca.enhancer.snps,
                        motifs, threshold = 0.9,
                        method = "ic",
                        emp.p.value = FALSE,
                        BPPARAM=BiocParallel::SerialParam())
}
\seealso{
See \code{\link{snps.from.rsid}} and \code{\link{snps.from.bed}} for
  information about how to generate the input to this function and \code{\link{plotMB}}
  for information on how to visualize it's output
}

